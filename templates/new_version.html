{% extends 'base.html' %}
{% block title %}
DB helper - ERD builder
{% endblock title %}

{% block content %}
<h3>User Code: {{current_user.userCode}}</h3>
<button id="test">Test</button> 
<button id="save">Save</button>

<div>
    <span id="debug-area">DEBUG SCORE :</span>
    <h4>Scenario</h4>
    <span>make a database for a used car sales system </span>
</div>
<br>
<span id="warning"></span>

<div id="nameWrapper">    
    <label for="databaseName">Database Name:</label>
    <input type="text" id="databaseNameInput" name="databaseName">
    <button id="setNameButton">Set name</button>
    <h3 id="databaseName"></h3>
</div>
<div id="table-design-wrapper">
    <div id="table-name-input-wrapper">
        <h4>Table Name:</h4>
        <!-- <label for="tableName">Table name:</label> -->
        <input id="tableNameInput" type="text">
        <button id="addTableButton">Add table</button>
    </div>
    
    <div id="field-inputs-wrapper">
        <h4>Field information:</h4>
        <label for="pkInput">Primary key:</label>
        <input id="pkInput" type="checkbox">
        <label for="fkInput">Foreign key:</label>
        <input type="checkbox" name="fkInput" id="fkInput">
        <!-- try to hide this input unless the fk check is checked ? -->
         <label for="fkSelect">References:</label>
        <select name="fkSelect" id="fkSelect">
        </select>
        <input id="fieldNameInput" type="text" placeholder="Field Name">
        <label for="fieldTypeInput">Type:</label>
        <select id="fieldTypeInput">
            <option value="INT">INT</option>
            <option value="VARCHAR">VARCHAR</option>
            <option value="BOOL">BOOL</option>
        </select>
        <button id="add-field-button" class="add-field">Add</button>
    </div>
    <br>

</div>

<div id="tables-wrapper">

</div>

<!-- 1nf wrapper -->
<pre id="mermaid-diagram" class="mermaid"></pre>
 <h3>1NF</h3>
 <pre id="mermaid-diagram-1nf" class="mermaid"></pre>

 <!-- 2nf wrapper -->
 <h3>2NF</h3>
 <pre id="mermaid-diagram-2nf" class="mermaid"></pre>

 <!-- 3nf wrapper -->
 <h3>3NF</h3>
<pre id="mermaid-diagram-3nf" class="mermaid"></pre>



{% endblock content %}


{% block scripts %}
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({startOnLoad:false});</script>
<script>

    var userScore = 0

    var scenarioObject = {
        "scenario_id": "2",
        "acceptable_variations": {
          "tables": [
            {
              "concept": "Cars Table",
              "acceptable_names": ["Cars", "Vehicles", "CarInventory","car_inventory"],
              "fields": [
                {
                  "concept": "Unique Car Identifier",
                  "acceptable_names": ["CarID", "VehicleID", "ID"],
                  "acceptable_types": ["INT", "BIGINT"],
                  "is_primary_key": true
                },
                {
                  "concept": "Car Make",
                  "acceptable_names": ["Make", "Manufacturer"],
                  "acceptable_types": ["VARCHAR(50)", "TEXT"],
                  "is_primary_key": false
                },
                {
                  "concept": "Car Model",
                  "acceptable_names": ["Model"],
                  "acceptable_types": ["VARCHAR(50)", "TEXT"],
                  "is_primary_key": false
                },
                {
                  "concept": "Year of Manufacture",
                  "acceptable_names": ["Year", "ManufactureYear"],
                  "acceptable_types": ["YEAR", "INT"],
                  "is_primary_key": false
                },
                {
                  "concept": "Price",
                  "acceptable_names": ["Price", "Cost"],
                  "acceptable_types": ["DECIMAL(10,2)", "FLOAT"],
                  "is_primary_key": false
                }
              ]
            },
            {
              "concept": "Sales Table",
              "acceptable_names": ["Sales", "Transactions", "CarSales"],
              "fields": [
                {
                  "concept": "Unique Sale Identifier",
                  "acceptable_names": ["SaleID", "TransactionID"],
                  "acceptable_types": ["INT", "BIGINT"],
                  "is_primary_key": true
                },
                {
                  "concept": "Sold Car Identifier",
                  "acceptable_names": ["CarID", "VehicleID"],
                  "acceptable_types": ["INT", "BIGINT"],
                  "is_primary_key": false,
                  "is_foreign_key": true,
                  "references": "Cars"
                },
                {
                  "concept": "Sales Staff Identifier",
                  "acceptable_names": ["StaffID", "EmployeeID"],
                  "acceptable_types": ["INT", "BIGINT"],
                  "is_primary_key": false,
                  "is_foreign_key": true,
                  "references": "Staff"
                },
                {
                  "concept": "Sale Date",
                  "acceptable_names": ["SaleDate", "TransactionDate"],
                  "acceptable_types": ["DATE", "DATETIME"],
                  "is_primary_key": false
                },
                {
                  "concept": "Sale Amount",
                  "acceptable_names": ["Amount", "SaleAmount", "Price"],
                  "acceptable_types": ["DECIMAL(10,2)", "FLOAT"],
                  "is_primary_key": false
                }
              ]
            },
            {
              "concept": "Staff Table",
              "acceptable_names": ["Staff", "Employees", "Team"],
              "fields": [
                {
                  "concept": "Unique Staff Identifier",
                  "acceptable_names": ["StaffID", "EmployeeID"],
                  "acceptable_types": ["INT", "BIGINT"],
                  "is_primary_key": true
                },
                {
                  "concept": "Staff Name",
                  "acceptable_names": ["Name", "FullName"],
                  "acceptable_types": ["VARCHAR(100)", "TEXT"],
                  "is_primary_key": false
                },
                {
                  "concept": "Staff Role",
                  "acceptable_names": ["Role", "Position"],
                  "acceptable_types": ["VARCHAR(50)", "TEXT"],
                  "is_primary_key": false
                }
              ]
            },
            {
              "concept": "Customers Table",
              "acceptable_names": ["Customers", "Clients", "Buyers"],
              "fields": [
                {
                  "concept": "Unique Customer Identifier",
                  "acceptable_names": ["CustomerID", "ClientID", "BuyerID"],
                  "acceptable_types": ["INT", "BIGINT"],
                  "is_primary_key": true
                },
                {
                  "concept": "Customer Name",
                  "acceptable_names": ["Name", "FullName"],
                  "acceptable_types": ["VARCHAR(100)", "TEXT"],
                  "is_primary_key": false
                },
                {
                  "concept": "Customer Phone",
                  "acceptable_names": ["Phone", "ContactNumber"],
                  "acceptable_types": ["VARCHAR(15)", "TEXT"],
                  "is_primary_key": false
                },
                {
                  "concept": "Customer Email",
                  "acceptable_names": ["Email", "EmailAddress"],
                  "acceptable_types": ["VARCHAR(100)", "TEXT"],
                  "is_primary_key": false
                }
              ]
            }
          ]
        }
      }

    var scenario2 = {
        "scenario_id": "3",
        "normal_forms": {
          "1NF": {
            "tables": [
              {
                "concept": "Student Enrollment",
                "acceptable_names": ["Enrollments", "StudentCourses", "Student_Enrollments"],
                "fields": [
                  {
                    "concept": "Unique Student Identifier",
                    "acceptable_names": ["StudentID", "student_ID"],
                    "acceptable_types": ["INT", "BIGINT"],
                    "is_primary_key": true
                  },
                  {
                    "concept": "Student Name",
                    "acceptable_names": ["Name", "FullName","student_name","student_fullname"],
                    "acceptable_types": ["VARCHAR(100)", "TEXT"],
                    "is_primary_key": false
                  },
                  {
                    "concept": "Course Name",
                    "acceptable_names": ["Course", "CourseTitle","course_title"],
                    "acceptable_types": ["VARCHAR(100)", "TEXT"],
                    "is_primary_key": false
                  },
                  {
                    "concept": "Grade",
                    "acceptable_names": ["Grade", "FinalGrade"],
                    "acceptable_types": ["VARCHAR(2)", "TEXT"],
                    "is_primary_key": false
                  }
                ]
              }
            ]
          },
          "2NF": {
            "tables": [
              {
                "concept": "Students Table",
                "acceptable_names": ["Students", "Learners"],
                "fields": [
                  {
                    "concept": "Unique Student Identifier",
                    "acceptable_names": ["StudentID", "ID","student_id"],
                    "acceptable_types": ["INT", "BIGINT"],
                    "is_primary_key": true
                  },
                  {
                    "concept": "Student Name",
                    "acceptable_names": ["Name", "FullName","student_name","student_fullname"],
                    "acceptable_types": ["VARCHAR(100)", "TEXT"],
                    "is_primary_key": false
                  },
				  {
                    "concept": "Student Email",
                    "acceptable_names": ["Email", "studentEmail"],
                    "acceptable_types": ["VARCHAR(100)", "TEXT"],
                    "is_primary_key": false
                  }
                ]
              },
              {
                "concept": "Enrollments Table",
                "acceptable_names": ["Enrollments", "StudentCourses"],
                "fields": [
                  {
                    "concept": "Unique Student Identifier",
                    "acceptable_names": ["StudentID", "ID"],
                    "acceptable_types": ["INT", "BIGINT"],
                    "is_primary_key": true,
                    "is_foreign_key": true,
                    "references": "Students"
                  },
                  {
                    "concept": "Course Name",
                    "acceptable_names": ["Course", "CourseTitle"],
                    "acceptable_types": ["VARCHAR(100)", "TEXT"],
                    "is_primary_key": true
                  },
                  {
                    "concept": "Grade",
                    "acceptable_names": ["Grade", "FinalGrade"],
                    "acceptable_types": ["VARCHAR(2)", "TEXT"],
                    "is_primary_key": false
                  }
                ]
              }
            ]
          },
          "3NF": {
            "tables": [
              {
                "concept": "Students Table",
                "acceptable_names": ["Students", "Learners"],
                "fields": [
                  {
                    "concept": "Unique Student Identifier",
                    "acceptable_names": ["StudentID", "ID"],
                    "acceptable_types": ["INT", "BIGINT"],
                    "is_primary_key": true
                  },
                  {
                    "concept": "Student Name",
                    "acceptable_names": ["Name", "FullName","student_name","student_fullname"],
                    "acceptable_types": ["VARCHAR(100)", "TEXT"],
                    "is_primary_key": false
                  },
				  {
                    "concept": "Student Email",
                    "acceptable_names": ["Email", "studentEmail","student_email"],
                    "acceptable_types": ["VARCHAR(100)", "TEXT"],
                    "is_primary_key": false
                  }
                ]
              },
              {
                "concept": "Courses Table",
                "acceptable_names": ["Courses", "Subjects"],
                "fields": [
                  {
                    "concept": "Unique Course Identifier",
                    "acceptable_names": ["CourseID", "CourseCode"],
                    "acceptable_types": ["INT", "BIGINT"],
                    "is_primary_key": true
                  },
                  {
                    "concept": "Course Name",
                    "acceptable_names": ["Course", "CourseTitle"],
                    "acceptable_types": ["VARCHAR(100)", "TEXT"],
                    "is_primary_key": false
                  }
                ]
              },
              {
                "concept": "Enrollments Table",
                "acceptable_names": ["Enrollments", "StudentCourses"],
                "fields": [
                  {
                    "concept": "Unique Student Identifier",
                    "acceptable_names": ["StudentID", "ID"],
                    "acceptable_types": ["INT", "BIGINT"],
                    "is_primary_key": true,
                    "is_foreign_key": true,
                    "references": "Students"
                  },
                  {
                    "concept": "Unique Course Identifier",
                    "acceptable_names": ["CourseID", "CourseCode"],
                    "acceptable_types": ["INT", "BIGINT"],
                    "is_primary_key": true,
                    "is_foreign_key": true,
                    "references": "Courses"
                  },
                  {
                    "concept": "Grade",
                    "acceptable_names": ["Grade", "FinalGrade"],
                    "acceptable_types": ["VARCHAR(2)", "TEXT"],
                    "is_primary_key": false
                  }
                ]
              }
            ]
          }
        }
      }

      //these hold the tables to build the digrams from 
    var tables_1nf=[]

    var tables_2nf=[]

    var tables_3nf=[]



    function checkTableName(name){
        let index = -1
        for(tbl of scenarioObject.acceptable_variations.tables){
            //console.log("scenario table = ",tbl)
            index = tbl.acceptable_names.findIndex(fname => fname.toLowerCase() == name.toLowerCase())
            //console.log("Index of name ",index)
            if(index > -1){
                console.log("Table Name is acceptable")
                return true
            }
        }
    }

    function checkFieldName(tableName,fieldName){
        let index = -1
        for(tbl of scenarioObject.acceptable_variations.tables){
            //find the table, assuming the table was acceptable 
            index = tbl.acceptable_names.findIndex(tname => tname.toLowerCase() == tableName.toLowerCase())
            
            if(index > -1){
                //loop over tables fields 
                //i think this is the problemn ??
                let jindex = -1
                for(fld of tbl.fields){
                    //somehow the variable is becoming undefined on the last loop ??
                    jindex = fld.acceptable_names.findIndex(fname => fname.toLowerCase() == fieldName.toLowerCase())
                    if(jindex > -1){
                        return true
                    }
                }

            }

        }
    }

    function checkTableName2(name){
        let index = -1
        for(tbl of scenario2.normal_forms["1NF"].tables){
            //console.log("1nf scenario table = ",tbl)
            index = tbl.acceptable_names.findIndex(fname => fname.toLowerCase() == name.toLowerCase())
            //console.log("Index of name ",index)
            if(index > -1){
                //console.log(`${name} Table is acceptable in 1NF`)
				//check it isnt duplicated 
				let jindex = -1
				jindex = tables_1nf.findIndex(table => table.name.toLowerCase() == name.toLowerCase())
				if(jindex > -1){
					//console.log(`Stopped duplicate of ${name} table`)
				}else{
					//add table to the 1nf tables 
					let newTable = { name: name, fields: [] }
					tables_1nf.push(newTable)
				}

				//dont duplicate 
				//break
            }
        }
        //2NF
        for(tbl of scenario2.normal_forms["2NF"].tables){
            //console.log("2nf scenario table = ",tbl)
            index = tbl.acceptable_names.findIndex(fname => fname.toLowerCase() == name.toLowerCase())
            //console.log("Index of name ",index)
            if(index > -1){
                //console.log(`${name} Table is acceptable in 2NF`)

				let jindex = -1
				jindex = tables_2nf.findIndex(table => table.name.toLowerCase() == name.toLowerCase())
				if(jindex > -1){
					//console.log(`Stopped duplicate of ${name} table`)
				}else{
					//add table to the 2nf tables 
					let newTable = { name: name, fields: [] }
					tables_2nf.push(newTable)
				}
            }
        }
        //3NF
        for(tbl of scenario2.normal_forms["3NF"].tables){
            //console.log(" 3nf scenario table = ",tbl)
            index = tbl.acceptable_names.findIndex(fname => fname.toLowerCase() == name.toLowerCase())
            //console.log("Index of name ",index)
            if(index > -1){
                //console.log(`${name} Table is acceptable in 3NF`)
                //return true
				let jindex = -1
				jindex = tables_3nf.findIndex(table => table.name.toLowerCase() == name.toLowerCase())
				if(jindex > -1){
					//console.log(`Stopped duplicate of ${name} table`)
				}else{
					//add table to the 1nf tables 
					let newTable = { name: name, fields: [] }
					tables_3nf.push(newTable)
				}
				
            }
        }
    }

	//THIS FUNCTION DOES WAAAAAAY TOO MUCH AND SHOULD BE BROKEN INTO MODULAR FUNCTIONS 
    function checkFieldName2(tableName,fieldName,fieldType,PK,FK){
        //console.log(`table name in field check = ${tableName}, field = ${fieldName}`)
		console.log("1NF")
        let index = -1
        for(tbl of scenario2.normal_forms["1NF"].tables){

            index = tbl.acceptable_names.findIndex(fname => fname.toLowerCase() == tableName.toLowerCase())

           if(index > -1){
                //check that the table has been entered in tables_1nf

                //check field name 
                let jindex = -1
                for(fld of tbl.fields){

                    jindex = fld.acceptable_names.findIndex(fname => fname.toLowerCase() == fieldName.toLowerCase())
                    console.log(`fieldname index = ${jindex}`)
                    if(jindex > -1){
                        //return true
                        //add to the 1nf tables list
                        console.log(`adding ${fieldName} to ${tableName} in 1NF`)
                    }
                }
                //return true
            }else{
                console.log(`adding ${fieldName} to a table in 1NF`)
            }
        }

		    console.log("2NF")
        //2NF
        index = -1
        for(tbl of scenario2.normal_forms["2NF"].tables){
            //find the table if it is in the scenario 
            index = tbl.acceptable_names.findIndex(fname => fname.toLowerCase() == tableName.toLowerCase())
            console.log(`2NF Index of ${tableName} table = ${index}`)
            if(index > -1){
                //console.log(`${tableName} table found in 2nf`)
				
				//check the table has been entered by the user 
				for(tbl2 of tables_2nf){
					//table has been entered by user 
					if(tableName == tbl2.name){
						console.log(`${tableName} is in 2nf tabls as ${tbl2.name}`)

						//the user has the table correct, do they have the field name correct ? 
						for(fld of tbl.fields){
							let jindex = -1
							jindex = fld.acceptable_names.findIndex(fname => fname.toLowerCase() == fieldName.toLowerCase())
							console.log(`field > ${fieldName} index = ${jindex}`)
							
							if(jindex > -1){
								//Return true
								//check that the field isnt already taken 
								console.log(`${fieldName} is in the acceptable names`)
								console.log("tabl 2 = ",tbl2)
								let tindex = -1
								tindex = tbl2.fields.findIndex(tbl2fld => tbl2fld.fieldName.toLowerCase() == fieldName.toLowerCase())
								if(tindex > -1){
									console.log("Duplicate field name 2NF = ",fieldName )
								}else{

									let fieldObject = {
										fieldName: fieldName,
										fieldType: fieldType,
										PK: PK,
										FK: FK
									}
									tbl2.fields.push(fieldObject)
								}
	
							}
						}
					}else{
						console.log(`${tableName} is not `)
					}
				}
                //return true
            }
        }

		console.log("3NF checking ",fieldName)
        //3NF
        index = -1
        for(tbl of scenario2.normal_forms["3NF"].tables){
            //console.log(" CF 3nf scenario table = ",tbl)
            index = tbl.acceptable_names.findIndex(fname => fname.toLowerCase() == tableName.toLowerCase())
            //console.log("CF Index of name ",index)
            if(index > -1){
                //console.log(`${tableName} table found in 3nf`)

				for(tbl2 of tables_3nf){

					if(tableName == tbl2.name){

						let jindex = -1
						for(fld of tbl.fields){

							jindex = fld.acceptable_names.findIndex(fname => fname.toLowerCase() == fieldName.toLowerCase())
							console.log(`3NF fieldname ${fieldName} index = ${jindex}`)

							if(jindex > -1){

								let tindex = -1
								tindex = tbl2.fields.findIndex(tbl2fld => tbl2fld.fieldName.toLowerCase() == fieldName.toLowerCase())
								if(tindex > -1){
									console.log("Duplicate field name 3NF = ",fieldName )
								}else{

									let fieldObject = {
										fieldName: fieldName,
										fieldType: fieldType,
										PK: PK,
										FK: FK
									}
									tbl2.fields.push(fieldObject)
									console.log(`adding ${fieldName} to ${tableName} in 3NF`)
								}
								//return true
							}
						}
					}
				}
                //return true
            }
        }
    }

	//this function will add the table to the diagrams when a field that matches is entered 
  //ust it when a field is added to the schema
	function addTableFromField(fieldObject){
		//loop over scenarios
		for(tbl of scenario2.normal_forms["1NF"].tables){
			//loop over the tables fields
			let jindex = -1
			for(fld of tbl.fields){
				jindex = fld.acceptable_names.findIndex(fldName => fldName.toLowerCase() == fieldObject.fieldName.toLowerCase())
				if(jindex > -1){
					//add the field to the table diagram 
					//add the table to the relevent diagram 
					//need to check if the table already exists 
				
					let newTable = { name: name, fields: [] }
          //just make it the first name 
          newTable.name = tbl.acceptable_names[0]
					newTable.fields.push(fieldObject)
					tables_1nf.push(newTable)
					//add the field ? 
				}
			}
		}

		for(tbl of scenario2.normal_forms["2NF"].tables){
			//loop over the tables fields
			let jindex = -1
			for(fld of tbl.fields){
				jindex = fld.acceptable_names.findIndex(fldName => fldName.toLowerCase() == fieldObject.fieldName.toLowerCase())
				if(jindex > -1){
					//add the field to the table diagram 
					//add the table to the relevent diagram 
          				
					let newTable = { name: name, fields: [] }
          newTable.name = tbl.acceptable_names[0]
					newTable.fields.push(fieldObject)
					tables_2nf.push(newTable)
				}
			}
		}

		for(tbl of scenario2.normal_forms["3NF"].tables){
			//loop over the tables fields
			let jindex = -1
			for(fld of tbl.fields){
				jindex = fld.acceptable_names.findIndex(fldName => fldName.toLowerCase() == fieldObject.fieldName.toLowerCase())
				if(jindex > -1){
					//add the field to the table diagram 
					//add the table to the relevent diagram 
          				
					let newTable = { name: name, fields: [] }
          //check that the name doesnt already exist ?? 
          newTable.name = tbl.acceptable_names[0]
					newTable.fields.push(fieldObject)
					tables_3nf.push(newTable)
				}
			}
		}

	}

    var testButton = document.getElementById("test")

    var tablesWrapper = document.getElementById("tables-wrapper")

    var databaseNameInput = document.getElementById("databaseNameInput")
    var databaseName = document.getElementById("databaseName")
    var setNameButton = document.getElementById("setNameButton")

    var tableNameInput = document.getElementById("tableNameInput")
    var addTableButton = document.getElementById("addTableButton")

    var pkInput = document.getElementById("pkInput")
    var fkInput = document.getElementById("fkInput")
    var fkSelect = document.getElementById("fkSelect")
    var fieldName = document.getElementById("fieldNameInput")
    var fieldType = document.getElementById("fieldTypeInput")
    var addfieldButton = document.getElementById("add-field-button")

    var databaseSchema ={}
    var tables = []

    var primaryKeys = []
    var relationships = []
    //when the db is fincished, place the tables into the databseschema to submit as 1 object 
    var altTables = {}

    var selectedTable = null

    function highlightTable(selected){
        var tableDivs = document.getElementsByClassName("table")
        //clear all other highlighted tables 
        for(let element of tableDivs){
            element.classList.remove("selected-table")
        }
        
        //loop and set the one with the correct id 
        for(let element of tableDivs){
            if(element.id == selected.id){
                element.classList.add("selected-table")
            }
        }
    }

    addfieldButton.addEventListener("click",function(event){
        //check for a selected table and give error if none if selected 
        if(selectedTable == null){
            displayWarning("Must select a table to add a field to")
            return
        }
        let tableName = selectedTable.id.replace("-table",'')
        let pk = pkInput.checked
        let fk = fkInput.checked
        let name = fieldName.value
        let type = fieldType.value
        //console.log("The fields attributes ",tableName,pk,fk,name,type)
        
        if (name == "") {
             //present error 
             displayWarning("There must be a field name")
             return
         } else if (name.length < 4) {
             displayWarning("Field name must have more than 3 characters")
             return
         }else if(name.includes(" ")){
             displayWarning("Field name must not contain a 'space' character")
             return
         }

        if(!checkPKConflict(pk,name)){

            
            var referenced = null
            if(fk == true){
                //get the referenced 
            //let refid = relationships.indexOf(rel => rel.pkField)
            let fkValue = fkSelect.value
            //console.log("FK SELECT ",fkSelect)
            for(tbl of tables){
                referenced = tbl.fields.find((fld) => fld.fieldId == fkValue)
                if(referenced){
                    //console.log("FK RELATIONSHIP ",referenced)
                    break
                }
            }
            //console.log("REF AFTER LOOP = ",referenced)
            addField(pk, fk,referenced, name, type, tableName)
            
            }else{
                //moved from above 
                addField(pk, fk,referenced, name, type, tableName)
                
            }
            
            //update the UI 
            //addFieldUI(tableName,name,type,pk,fk)
            updateUIFromState()
        }else{
            displayWarning("Primary key conflict")
        }
    })

    function checkPKConflict(PK,fieldName){
        //chech that the Primary key doesnt exist in another table 
        for(tbl of tables){
            let conflict = tbl.fields.find((fld) => fld.fieldName == fieldName && fld.PK == PK )
            if(conflict){
                console.log("PRIOMARY KEY CONFLICT = ",conflict)
                return true
            }
        }
        return false
    }

    setNameButton.addEventListener("click",function(event){
        if(databaseNameInput.value == ""){
            displayWarning("Database name must not be blank")
            return
        }else if(databaseNameInput.value.length < 4){
            displayWarning("Database name must be more than 3 characters")
            return
        }else{
            databaseName.innerText = databaseNameInput.value
            //SANITIZE
            databaseSchema['name'] = databaseNameInput.value
        }
    })

    function getMermaidRelationship(relationship) {
        const { pkField, fkField } = relationship;
        const pkTableName = pkField.fieldId.split("_")[1]; 
        const fkTableName = fkField.fieldId.split("_")[1];
      
        return `${pkTableName} ||--o{ ${fkTableName} : ${pkField.fieldName} }`; 
      }

    testButton.addEventListener("click",function(event){
        console.log("TABLES STATE ",tables)
        console.log("RELATIONSHIPS STATE ",relationships)

        let mermaidCode = ""
        for (const relationship of relationships) {
            try{

                mermaidCode += getMermaidRelationship(relationship) + "\n"; 
            }catch (error) {
                console.error("Mermaid relationship error:", error);
            }
        }
        console.log("Mermaid relationships : ", mermaidCode)

        updateUIFromState()
        //renderDiagram(tables)
    })

    addTableButton.addEventListener('click', function(e) {
        event.preventDefault()
        let tname = tableNameInput.value

        if (tname == "") {
            //present error 
            displayWarning("There must be a table name")

        } else if (tname.length < 4) {

            displayWarning("Table name must have more than 3 characters")

        }else if(tname.includes(" ")){

            displayWarning("Table name must not contain a 'space' character")
        
        } else {

            //this is the UI 
            //can probably be replaced with the updateUIFromState function 
            //addTable(tname)
            
            tableNameInput.value = ""
            //add to the global list here 
            let newTable = { name: tname, fields: [] }
            
            //add table to list 
            tables.push(newTable)
            altTables[tname] = newTable

            //update UI after setting state
            updateUIFromState()
        }

    })

    //might need to keep a list of names and stop conflicts 
    function addTable(tableName) {

        //create the base empty div 
        let tableDiv = document.createElement("div")
        tableDiv.id = tableName + "-table"
        tableDiv.classList.add("table") // this should set all of the styles ?? 


        let nameDiv = document.createElement("div")
        nameDiv.id = tableName + "-name"
        nameDiv.className = "table-name"
        nameDiv.innerHTML = tableName
        nameDiv.style.width = tableDiv.style.width + "px"

        //remove table button 
        let removeTable = document.createElement("button")
        removeTable.innerText = "X"

        //tableDiv.appendChild(inputWrapper)
        nameDiv.appendChild(removeTable)
        tableDiv.appendChild(nameDiv)

        //remove table 
        removeTable.addEventListener("click",function(event){
            //get the tables wrapper then remove that element from it 
            //change the state then re-render
            let tableIndex = tables.findIndex(tbl => tbl.name == tableName)
           // console.log("REMOVING index = ",tableIndex)
            tables.splice(tableIndex,1)
            updateUIFromState()
        })

        //add event listene so the user can click to select the table to add a field 
        tableDiv.addEventListener("click", function(event){
            selectedTable = tableDiv
            //console.log("table selected = ", tableDiv)
            highlightTable(selectedTable)
        })

        tablesWrapper.append(tableDiv)

    }

    //creates the field and adds it to the table object in the tables list  
    function addField(PK = false, FK = false,referenced = null, fieldName, fieldType, tableName) {

        let fieldId = fieldName+"_"+tableName
        //create the field object 
        let fieldObject = {
            fieldId:fieldId,
            fieldName: fieldName,
            fieldType: fieldType,
            PK: PK,
            FK: FK
        }

        if(PK ==true){
            //make a relationship object 
            let relationshipObject ={
                pkField:fieldObject,
                fkField:null
            }
            //add it to the list of relationships 
            relationships.push(relationshipObject)
            //update the UI list 
            updateFKSelectOptions(fieldId,fieldName)
        }

        if(FK == true && referenced != null){
            let found = relationships.find((rel) => rel.pkField.fieldId == referenced.fieldId)
            //set the foreign side of the relationship
            found.fkField = fieldObject
            console.log("RELATIONSHIPS = ",relationships)
        }

        //add it to the tables field list        
        for (t of tables) {
            if (t.name == tableName) { //might be ablt to use the selected table variable here now 
                t.fields.push(fieldObject)
            }
        }

        //testing new version 
        addTableFromField(fieldObject)
    }

    function updateFKSelectOptions(fieldId, name){
        //could be better to loop through the relationships array and take the primary keys ?
        //field id can be the value of the select 
        let option = document.createElement("option")
        option.value = fieldId
        option.innerHTML = name

        fkSelect.add(option)
    }

    //i think this needs to be async ? 
    //build the fields UI from the state of the tables fields 
    function addFieldUI(tableName,name,type,PK = false,FK = false) {
        //find the correct table 
        let parentTable = document.getElementById(tableName + "-table")

        for (tbl of tables) {
            if (tbl.name == tableName) {
                console.log("UI 2 table:",tbl)
                addFieldToTable(parentTable,name,type,PK,FK)

            }
        }

    }
    //UI
    function addFieldToTable(parent,field_name = null, fieldType = null,PK = false, FK = false ) {

        let tableName = parent.id
        tableName = tableName.substring(0, tableName.length - 6);

        var nameInput = document.querySelector("#" + parent.id + " #fieldNameInput")
        var typeInput = document.querySelector("#" + parent.id + " #fieldTypeInput")

        var name = ""
        var type = ""
        //get the value from inputs of the parent 
        if(field_name != null){
            name = field_name
        }else{
            name = nameInput.value
        }

        if(fieldType != null){
            type = fieldType
        }else{
            type = typeInput.value
        }

        let fieldDiv = document.createElement("div")
        fieldDiv.style.width = parent.offsetWidth - 6 + "px";
        fieldDiv.className = "field2"
        if(PK == true){
            //not sure i need the below code ??
            let pkimage = document.createElement("img")
            pkimage.src = "{{url_for('static', filename='icons/pk_icon.png')}}"
            pkimage.width = "30px" 
            fieldDiv.appendChild(pkimage)
            
            let pkimgsrc = "{{url_for('static', filename='icons/pk_icon2.png')}}"
            fieldDiv.innerHTML = "<img id='pk-image' src=" +pkimgsrc+">" 

            fieldDiv.classList.add("primary-key")
        }
        
        if(FK == true){
            let fkimgsrc = "{{url_for('static', filename='icons/fk_icon.png')}}"
            fieldDiv.innerHTML = "<img id='fk-image' src=" +fkimgsrc+">" 

            fieldDiv.classList.add("foreign-key")

        }

        fieldDiv.innerHTML += "<span id='field-name'>" + name + "</span>"
        fieldDiv.innerHTML += "<span>" + type+ "</span>"
        
        let removeFieldButton = document.createElement("button")
        removeFieldButton.innerText = "X"

        removeFieldButton.addEventListener("click", function(event){
            console.log("REMOVE FIELD EVENT TARGET ", event.target.parentElement)
            let fieldDiv = event.target.parentElement
            let tableDiv = fieldDiv.parentElement

            let fieldName = fieldDiv.querySelector("#field-name")
            //console.log("NAME ",fieldName.innerText)

            //attempt to remove field from state. Probably a bad idea to modify the state here 
            for (tbl of tables) {
                if (tbl.name == tableName) {
                    if(tbl.fields.length > 0){
                        //get index of item to remove 
                        let index = tbl.fields.findIndex(field => field.fieldName == fieldName.innerText)
                        console.log("INDEX",index)
                        
                        //slice the fields array tro remove at the index 
                        if(index !== -1){
                            tbl.fields.splice(index,1)
                        }
                        
                    }
                }
            }
            //DONT FORGET THE STATE 
            tableDiv.removeChild(fieldDiv)
            updateUIFromState()
        })
        //cear the text 
        fieldName.value = ""
        //TODO :: CREATE A FUNCTION TO CLEAR THE FIELD INPUTS
        fieldDiv.appendChild(removeFieldButton)
        parent.appendChild(fieldDiv)
    }

    //this function builds / re-renders the tables 
    function updateUIFromState() {
        //reset the score 
        userScore = 0
        //clear the old UI ?
        tablesWrapper.innerHTML = ""
        //loop over the tables list and update the UI 
        for(tbl of tables){
            //draw the tables 
            const tablename = tbl.name
            addTable(tbl.name)
            //SET THE SCORE 
            if(checkTableName(tbl.name)){
                incramentUserScore()
            }
            //TESTING 
            //if(checkTableName2(tablename)){

            //}
        }
        //tables need to be added before the fields 

        for(tbl of tables){
            let parentTable = document.getElementById(tbl.name + "-table")
            
            //this was needed due to a bug that occured when tryinh to use tbl.name in the inner loop
            var tableName = tbl.name
            
            for(fld of tbl.fields){

                var fieldName = fld.fieldName
				var fieldType = fld.fieldType
				var fieldPK = fld.PK
				var fieldFK = fld.FK
                
                addFieldToTable(parentTable,fld.fieldName,fld.fieldType,fld.PK,fld.FK)
                
                if(checkFieldName(tableName,fieldName)){
                    console.log("field name = ",fieldName, " is OK")
                    //incrament the score
                    //userScore += 1
                    incramentUserScore()
                }else{
                    console.log("field name = ",fieldName, " is NOT OK")
                }

                //testing 2ndscenario
                
				//checkFieldName2(tableName,fieldName,fieldType,fieldPK,fieldFK)
				//testing the tables
			
				console.log("1nf tables object = ",tables_1nf)
				console.log("2nf tables object = ",tables_2nf)
				console.log("3nf tables object = ",tables_3nf)
            }
        }
        //TODO :: set the selected table highlight 
        if(selectedTable){
            highlightTable(selectedTable)
        }

        //TODO : reset the select for foreign key reference

        //MERMAID BIT 
        renderDiagram(tables)
        //1nf diagram
        renderDiagram(tables_1nf,"mermaid-diagram-1nf")
        //2nf diagram
        renderDiagram(tables_2nf,"mermaid-diagram-2nf")
        //3nf diagram
        renderDiagram(tables_3nf,"mermaid-diagram-3nf")
    }

    function incramentUserScore(amount = 1){
        userScore += amount
        updateUserScore()
    }

    //update userscroe function and show it in UI 
    function updateUserScore(){
        document.getElementById("debug-area").innerText = "user score = " +userScore
    }

    /**
    * displays a warning message for "timeOut" amount of milliseconds. timeout default 2000 milliseconds
    */
    function displayWarning(message,timeOut = 2000) {
        let warningText = document.getElementById("warning")
        warningText.innerText = message
        setTimeout(() => {
            warningText.innerText = ""
        }, timeOut)
    }

    //test the save 
    document.getElementById("save").addEventListener("click",function(e){

        fetch('/save',{
            method:'POST',
            headers:{
                'Content-Type':'application/json'
            },
            body: JSON.stringify(tables)
        })
        .then(response => response.json())
        .then(data => console.log(data))
        .catch(error => console.error("Error: ",error))

    })




    function createMermaidCode(tables) {
        let mermaidCode = "erDiagram\n";
        for (const table of tables) {
          mermaidCode += `    ${table.name} {\n`;
          for (const attribute of table.fields) {
            mermaidCode += `        ${attribute.fieldType} ${attribute.fieldName} ${attribute.PK ? 'PK' : ''} ${attribute.FK ? 'FK' : ''}\n`;
          }
          mermaidCode += "    }\n";
        }

        // do the relationships 
        return mermaidCode;
    }
  
    async function renderDiagram(tables,div = 'mermaid-diagram') {
        const mermaidCode = createMermaidCode(tables);
        //const diagramDiv = document.getElementById('mermaid-diagram');
        const diagramDiv = document.getElementById(div);
    
        console.log("TEH MERMAID CODE = ", mermaidCode);
    
        try {
            const uniqueId = `diagram-${div}`;
            const { svg } = await mermaid.render(uniqueId, mermaidCode);
            //const { svg } = await mermaid.render('generatedDiagram', mermaidCode);
            diagramDiv.innerHTML = svg;
        } catch (error) {
            console.error("Mermaid rendering error:", error);
        }
    }

    // Ensure Mermaid is initialized before calling renderDiagram
document.addEventListener("DOMContentLoaded", () => {
    mermaid.initialize({ startOnLoad: false });
});

</script>
{% endblock scripts %}